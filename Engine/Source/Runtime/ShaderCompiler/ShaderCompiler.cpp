#include "ShaderCompiler.h"

#pragma comment(lib, "dxcompiler")  

ShaderCompiler& ShaderCompiler::Instance()
{
    static ShaderCompiler Inst;
    return Inst;
}

void ShaderCompiler::Init()
{
    assert(SUCCEEDED(DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&_DXCUtils))));
    assert(SUCCEEDED(DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&_DXCCompiler))));
}

void ShaderCompiler::Destroy()
{
    _DXCCompiler.Reset();
    _DXCUtils.Reset();

   
}

void ShaderCompiler::CompileHLSL(const CompileArgs& args)
{
//    IDxcIncludeHandler* dxcIncludeHandler;
//    _DXCUtils->CreateDefaultIncludeHandler(&dxcIncludeHandler);
//
//    LPCWSTR pszArgs[] =
//    {
//        L"myshader.hlsl",            // Optional shader source file name for error reporting
//        // and for PIX shader source view.  
//L"-E", L"main",              // Entry point.
//L"-T", L"ps_6_0",            // Target.
//L"-Zs",                      // Enable debug information (slim format)
//L"-D", L"MYDEFINE=1",        // A single define.
//L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
//L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied
//// or the autogenerated file name must be used.
//L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
//    };
//
//    IDxcBlobEncoding* dxcSource = nullptr;
//    dxcUtils->LoadFile(shaderFileName.c_str(), nullptr, &dxcSource);
//    DxcBuffer sourceBuffer = {
//         .Ptr = dxcSource->GetBufferPointer(),
//         .Size = dxcSource->GetBufferSize(),
//         .Encoding = DXC_CP_ACP,
//    };
// 
//    IDxcResult* dxcResults = nullptr;
//    dxcCompiler->Compile(
//        &sourceBuffer,           
//        pszArgs,                 
//        _countof(pszArgs),      
//        dxcIncludeHandler,
//        IID_PPV_ARGS(&dxcResults) 
//    );
//
//    //
//    // Print errors if present.
//    //
//    IDxcBlobUtf8* dxcErrors = nullptr;
//    dxcResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&dxcErrors), nullptr);
//    // Note that d3dcompiler would return null if no errors or warnings are present.
//    // IDxcCompiler3::Compile will always return an error buffer, but its length
//    // will be zero if there are no warnings or errors.
//    if (dxcErrors != nullptr && dxcErrors->GetStringLength() != 0)
//        wprintf(L"Warnings and Errors:\n%S\n", dxcErrors->GetStringPointer());
//
//    //
//    // Quit if the compilation failed.
//    //
//    HRESULT hrStatus;
//    dxcResults->GetStatus(&hrStatus);
//    if (FAILED(hrStatus))
//    {
//        wprintf(L"Compilation Failed\n");
//        return 1;
//    }
//
//    //
//    // Save shader binary.
//    //
//    IDxcBlob* dxcShader = nullptr;
//    IDxcBlobUtf16* dxcShaderName = nullptr;
//    dxcResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&dxcShader), &dxcShaderName);
//    if (dxcShader != nullptr)
//    {
//        FILE* fp = NULL;
//
//        _wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
//        fwrite(dxcShader->GetBufferPointer(), dxcShader->GetBufferSize(), 1, fp);
//        fclose(fp);
//    }
//
//    //
//    // Save pdb.
//    //
//    IDxcBlob* dxcPDB = nullptr;
//    IDxcBlobUtf16* dxcPDBName = nullptr;
//    dxcResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&dxcPDB), &dxcPDBName);
//    {
//        FILE* fp = NULL;
//
//        // Note that if you don't specify -Fd, a pdb name will be automatically generated.
//        // Use this file name to save the pdb so that PIX can find it quickly.
//        _wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
//        fwrite(dxcPDB->GetBufferPointer(), dxcPDB->GetBufferSize(), 1, fp);
//        fclose(fp);
//    }
//
//    //
//    // Print hash.
//    //
//    IDxcBlob* dxcHash = nullptr;
//    dxcResults->GetOutput(DXC_OUT_SHADER_HASH, IID_PPV_ARGS(&dxcHash), nullptr);
//    if (dxcHash != nullptr)
//    {
//        wprintf(L"Hash: ");
//        DxcShaderHash* dxcHashBuf = (DxcShaderHash*)dxcHash->GetBufferPointer();
//        for (int i = 0; i < _countof(dxcHashBuf->HashDigest); i++)
//            wprintf(L"%.2x", dxcHashBuf->HashDigest[i]);
//        wprintf(L"\n");
//    }
//
//    //
//    // Demonstrate getting the hash from the PDB blob using the IDxcUtils::GetPDBContents API
//    //
//    IDxcBlob* dxcHashDigestBlob = nullptr;
//    IDxcBlob* dxcDebugDxilContainer = nullptr;
//    if (SUCCEEDED(dxcUtils->GetPDBContents(dxcPDB, &dxcHashDigestBlob, &dxcDebugDxilContainer)))
//    {
//        // This API returns the raw hash digest, rather than a DxcShaderHash structure.
//        // This will be the same as the DxcShaderHash::HashDigest returned from
//        // IDxcResult::GetOutput(DXC_OUT_SHADER_HASH, ...).
//        wprintf(L"Hash from PDB: ");
//        const BYTE* pHashDigest = (const BYTE*)dxcHashDigestBlob->GetBufferPointer();
//        assert(dxcHashDigestBlob->GetBufferSize() == 16); // hash digest is always 16 bytes.
//        for (int i = 0; i < dxcHashDigestBlob->GetBufferSize(); i++)
//            wprintf(L"%.2x", pHashDigest[i]);
//        wprintf(L"\n");
//
//        // The pDebugDxilContainer blob will contain a DxilContainer formatted
//        // binary, but with different parts than the pShader blob retrieved
//        // earlier.
//        // The parts in this container will vary depending on debug options and
//        // the compiler version.
//        // This blob is not meant to be directly interpreted by an application.
//    }
//
//    //
//    // Get separate reflection.
//    //
//    IDxcBlob* dxcReflectionData;
//    dxcResults->GetOutput(DXC_OUT_REFLECTION, IID_PPV_ARGS(&dxcReflectionData), nullptr);
//    if (dxcReflectionData != nullptr)
//    {
//        // Optionally, save reflection blob for later here.
//
//        // Create reflection interface.
//        DxcBuffer ReflectionData;
//        ReflectionData.Encoding = DXC_CP_ACP;
//        ReflectionData.Ptr = dxcReflectionData->GetBufferPointer();
//        ReflectionData.Size = dxcReflectionData->GetBufferSize();
//
//        ID3D12ShaderReflection* dxcReflection;
//        dxcUtils->CreateReflection(&ReflectionData, IID_PPV_ARGS(&dxcReflection));
//
//        // Use reflection interface here.
//
//    }
}